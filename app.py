import faicons as fa
import numpy as np
from pathlib import Path
from core import (
    plot_diversification,
    tangency_point,
    plot_frontier,
    plot_mv,
    crra,
    crra_inv,
    expected_utility,
    expected_value,
    std,
    moment,
)
from shiny import App, render, ui, reactive

app_dir = Path(__file__).parent

mathjax = ui.head_content(
    ui.tags.script(
        src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    ),
    ui.tags.script("if (window.MathJax) MathJax.Hub.Queue(['Typeset', MathJax.Hub]);"),
)

app_ui = ui.page_navbar(
    mathjax,
    ui.nav_panel(
        "Diversification",
        ui.layout_columns(
            ui.card(
                ui.card_header("Risk vs Portfolio Size"),
                ui.output_plot("diverse"),
                ui.card_footer(
                    ui.input_slider(
                        "num_stocks",
                        "Number of Stocks",
                        min=2,
                        max=30,
                        value=10,
                    )
                ),
                height="650px",
            ),
            ui.markdown(
                """
            #### Diversification
            ---
            Portfolios of stocks all with the same standard deviation and pairwise correlations.
            The more stocks we add, the more we reduce the risk of the portfolio.
            The risk of the portfolio will never
            be zero but will asymptotically approach a minimum value, unless the correlation is zero.
            The minimum risk is:
            $$ \sigma_p = \sigma \sqrt{\\frac{1 + (N-1)\\rho)}{N}} $$
            Letting _N_ go to infinity, we get:
            $$ \lim_{N \\to \infty} \sigma_p = \sigma \sqrt{\\rho} $$
            So for example the red line with a correlation of 0.25 will have a minimum risk of 5%.
            $$ \sigma  \sqrt{\\rho}= 10 \sqrt{0.25} = (10)(0.5) = 5$$
                """
            ),
            col_widths=[8, 4],
        ),
    ),
    ui.nav_panel(
        "2 Stocks",
        ui.layout_columns(
            ui.card(
                ui.card_header("Mean Variance Frontier for 2 Risky Assets"),
                ui.output_plot(id="asset2_rf"),
                ui.card_footer(
                    ui.input_switch(
                        id="cml2", label="Capital Market Line", value=False
                    ),
                ),
                full_screen=True,
            ),
            ui.markdown(
                """
            #### 2 Risky Assets
            ---
            *Returns*: 8%, 15%  
            *Standard Deviations*: 10%, 30%  
            *Correlation*: 0.0  

            ---
            Notice that both stocks lie on the minimum variance frontier, 
            this is due to the fact that there is a unique combination of 
            the two stock that make up each return. That is  
            $$𝑤_2 = 1 − 𝑤_1$$ 
            Since all possible returns are generated by a portfolio of these 
            two stocks and both stocks lie on the frontier, we trivially 
            obtain a separation theorem. That is every investor chooses a 
            portfolio that is a linear combination of two frontier portfolios. 
            We will see in the 𝑁 > 2  case that the stocks generally do not 
            lie on the frontier, but that the separation theorem is still true!
                """
            ),
            col_widths=[8, 4],
            height="650px",
        ),
    ),
    ui.nav_panel(
        "Portfolios",
        ui.layout_columns(
            ui.card(
                ui.card_header("Frontiers for Small Portfolios"),
                ui.output_plot("mvfs"),
                ui.card_footer(
                    ui.input_checkbox_group(
                        "portfolio_size",
                        "Portfolio Sizes",
                        {
                            2: "2",
                            3: "3",
                            4: "4",
                        },
                        selected=[2, 3, 4],
                        inline=True,
                    ),
                ),
                height="700px",
            ),
            ui.markdown(
                """
            #### Building the Efficient Frontier from Smaller Portfolios
            ---
            Five stocks in μ-σ space, reflecting different combinations of expected return (μ) and risk (σ). If portfolio size 2 is selected
            all possible combinations of the assets two at a time are plotted. And similarly for 3 and 4 stock portfolios. 
            As more and more combinations are created, the curves accumulate to show the growing number of possible portfolios. 
            The accumulation of curves outlines a space representing all possible combinations of the original five stocks.
                """
            ),
            col_widths=[8, 4],
            height="650",
        ),
    ),
    ui.nav_panel(
        "3 Stocks",
        ui.layout_columns(
            ui.card(
                ui.card_header("Mean Variance Frontier for 3 Risky Assets"),
                ui.output_plot("asset3_rf"),
                ui.input_switch(id="cml3", label="Capital Market Line", value=True),
            ),
            ui.markdown(
                """
            #### 3 Risky Assets
            ---
            *Returns*: 10%, 17%, 20%  
            *Standard Deviations*: 15%, 25%, 35%  
            *Correlation*: 0.0  

            ---
            Now the stocks do not all lie on the frontier, but the separation theorem still holds.
            Any efficient portfolio can be constructed as a linear combination of the
            risk free asset and the tangency portfolio. The tangency portfolio (TP).
                """
            ),
            col_widths=[8, 4],
            height="650px",
        ),
    ),
    ui.nav_panel(
        "Utility",
        ui.layout_columns(
            ui.card(
                ui.input_slider(
                    "risk_aversion",
                    "Relative Risk Aversion",
                    min=0,
                    max=10,
                    step=0.5,
                    value=2.0,
                ),
                ui.output_text("ev"),
                ui.output_text("sd"),
                ui.output_text("sk"),
                ui.output_text("kurt"),
                ui.hr(style="margin: 0px"),
                ui.output_text("eu"),
                ui.output_text("ce"),
                ui.output_text("rp"),
            ),
            ui.card(
                ui.card_header("Payoffs (% Wealth)"),
                ui.input_numeric("payoff1", "", value=25, step=1),
                ui.input_numeric("payoff2", "", value=-15, step=1),
                ui.input_numeric("payoff3", "", value=0, step=1),
                ui.input_numeric("payoff4", "", value=0, step=1),
                ui.input_numeric("payoff5", "", value=0, step=1),
            ),
            ui.card(
                ui.card_header("Probabilities (%)"),
                ui.input_numeric("prob1", "", value=50, step=1),
                ui.input_numeric("prob2", "", value=50, step=1),
                ui.input_numeric("prob3", "", value=0, step=1),
                ui.input_numeric("prob4", "", value=0, step=1),
                ui.input_numeric("prob5", "", value=0, step=1),
                ui.output_text("total_prob"),
            ),
            ui.markdown(
                """
            #### Expected Utility
            ---
            We caluculate the epected utility and related quantities of a portfolio with the given payoffs and probabilities using the CRRA (power) utility function:
            $$ u(w) = \\frac{w^{1-\\gamma} - 1}{1-\\gamma} $$
            γ is the relative risk aversion.

            Our measure of skewness is the third central moment of the distribution:
            $$ E\\left[\\left(\\frac{W - \\mu}{\\sigma}\\right)^3\\right] $$
                """
            ),
            col_widths=[3, 2, 2, 5],
        ),
    ),
    title="Asset Pricing",
)


def server(input, output, session):
    @render.plot
    def diverse():
        return plot_diversification(0.1, 0, 0.25, 0.5, input.num_stocks())

    @render.plot
    def asset2_rf():
        c = 0
        means = np.array(
            [
                8 / 100,
                15 / 100,
            ]
        )
        cov = np.array(
            [
                [(10 / 100) ** 2, c],
                [c, (30 / 100) ** 2],
            ]
        )
        rf = 0.05 if input.cml2() else None
        return plot_frontier(means, cov, 0.05, 0.16, rf=rf)

    @render.plot
    def asset3_rf():
        means = np.array(
            [
                10 / 100,
                17 / 100,
                0.2,
            ]
        )
        cov = np.array(
            [
                [(15 / 100) ** 2, 0, 0],
                [0, (25 / 100) ** 2, 0],
                [0, 0, (35 / 100) ** 2],
            ]
        )
        tangency_point(means, cov, 0.05)
        rf = 0.05 if input.cml3() else None
        return plot_frontier(means, cov, 0.05, 0.25, rf=rf)

    @render.plot
    def mvfs():
        return plot_mv(input.portfolio_size())

    @reactive.calc
    def utility():
        uf = lambda x: crra(1 + x, input.risk_aversion())
        return expected_utility(
            uf,
            (input.payoff1() / 100 or 0),
            (input.payoff2() / 100 or 0),
            (input.payoff3() / 100 or 0),
            (input.payoff4() / 100 or 0),
            (input.payoff5() / 100 or 0),
            (input.prob1() / 100 or 0),
            (input.prob2() / 100 or 0),
            (input.prob3() / 100 or 0),
            (input.prob4() / 100 or 0),
            (input.prob5() / 100 or 0),
        )

    @reactive.calc
    def expected_val():
        return 100 * expected_value(
            (1 + input.payoff1() / 100 or 1),
            (1 + input.payoff2() / 100 or 1),
            (1 + input.payoff3() / 100 or 1),
            (1 + input.payoff4() / 100 or 1),
            (1 + input.payoff5() / 100 or 1),
            (input.prob1() / 100 or 0),
            (input.prob2() / 100 or 0),
            (input.prob3() / 100 or 0),
            (input.prob4() / 100 or 0),
            (input.prob5() / 100 or 0),
        )

    def standard_dev():
        return 100 * std(
            (input.payoff1() / 100 or 1),
            (input.payoff2() / 100 or 1),
            (input.payoff3() / 100 or 1),
            (input.payoff4() / 100 or 1),
            (input.payoff5() / 100 or 1),
            (input.prob1() / 100 or 0),
            (input.prob2() / 100 or 0),
            (input.prob3() / 100 or 0),
            (input.prob4() / 100 or 0),
            (input.prob5() / 100 or 0),
        )

    def skewness():
        return moment(
            3,
            (input.payoff1() / 100 or 1),
            (input.payoff2() / 100 or 1),
            (input.payoff3() / 100 or 1),
            (input.payoff4() / 100 or 1),
            (input.payoff5() / 100 or 1),
            (input.prob1() / 100 or 0),
            (input.prob2() / 100 or 0),
            (input.prob3() / 100 or 0),
            (input.prob4() / 100 or 0),
            (input.prob5() / 100 or 0),
        )

    def kurtosis():
        return moment(
            4,
            (input.payoff1() / 100 or 1),
            (input.payoff2() / 100 or 1),
            (input.payoff3() / 100 or 1),
            (input.payoff4() / 100 or 1),
            (input.payoff5() / 100 or 1),
            (input.prob1() / 100 or 0),
            (input.prob2() / 100 or 0),
            (input.prob3() / 100 or 0),
            (input.prob4() / 100 or 0),
            (input.prob5() / 100 or 0),
        )

    @render.text
    def eu():
        u = utility()
        return f"Expected Utility:  {u:.3f}"

    @render.text
    def ce():
        u = utility()
        w = crra_inv(u, input.risk_aversion())
        return f"Certainty Equiv. Return: {-100 + 100 * w:.2f}%"

    @render.text
    def ev():
        v = expected_val()
        return f"Expected Return: {v-100:.2f}%"

    @render.text
    def sd():
        v = standard_dev()
        return f"Standard Deviation: {v:.2f}%"

    @render.text
    def sk():
        v = skewness()
        return f"Skewness: {v:.2f}"

    @render.text
    def kurt():
        v = kurtosis()
        return f"Kurtosis: {v:.2f}"

    @render.text
    def rp():
        ce = 100 * crra_inv(utility(), input.risk_aversion())
        v = expected_val()
        return f"Risk Premium: {v - ce:.3f}%"

    @render.text
    def accept():
        if crra_inv(utility() / 100, input.risk_aversion()) > 1:
            return "Accepted: YES"
        return "Accepted: NO"

    @render.text
    def total_prob():
        total = (
            input.prob1()
            + input.prob2()
            + input.prob3()
            + input.prob4()
            + input.prob5()
        )
        return f"Total: {total}"


app = App(app_ui, server)
